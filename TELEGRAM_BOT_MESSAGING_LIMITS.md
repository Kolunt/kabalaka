# Ограничения отправки сообщений в Telegram боте

## Краткий ответ

**Нет, бот не может написать пользователю, который никогда не взаимодействовал с ботом.**

## Ограничения Telegram API

Telegram API имеет строгие ограничения для защиты от спама:

### ✅ Бот МОЖЕТ отправить сообщение, если:

1. **Пользователь написал боту первым**:
   - Отправил команду `/start`
   - Отправил любое сообщение боту
   - Нажал на кнопку в боте

2. **У бота есть chat_id пользователя** (из предыдущего взаимодействия)

### ❌ Бот НЕ МОЖЕТ отправить сообщение, если:

1. **Пользователь никогда не писал боту**:
   - Ошибка: `BadRequest: chat not found`
   - Это защита от спама

2. **Пользователь заблокировал бота**:
   - Ошибка: `Forbidden: bot was blocked by the user`
   - Бот не может отправить сообщение до разблокировки

3. **Пользователь деактивировал аккаунт**:
   - Ошибка: `Forbidden: user is deactivated`
   - Аккаунт удален или временно недоступен

## Как это работает в вашем боте

### Текущая реализация

1. **Регистрация пользователя**:
   - При отправке `/start` пользователь автоматически регистрируется в базе данных
   - Сохраняется `user_id`, `username`, `first_name`

2. **Отправка уведомлений**:
   - Бот отправляет уведомления только пользователям, которые:
     - Есть в базе данных (отправили `/start`)
     - Имеют подключенные календари
   - Если пользователь заблокировал бота или не зарегистрирован, ошибка логируется, но не прерывает работу

3. **Обработка ошибок**:
   - Улучшена обработка ошибок в функции `send_notification`
   - Различаются типы ошибок:
     - `chat not found` - пользователь не зарегистрирован
     - `bot was blocked` - пользователь заблокировал бота
     - `user is deactivated` - аккаунт деактивирован

## Примеры ошибок в логах

### Пользователь не зарегистрирован:
```
WARNING: Пользователь 123456789 не зарегистрирован в боте (никогда не отправлял /start). Пропуск уведомления.
```

### Пользователь заблокировал бота:
```
WARNING: Пользователь 123456789 заблокировал бота. Пропуск уведомления.
```

### Пользователь деактивировал аккаунт:
```
WARNING: Пользователь 123456789 деактивировал аккаунт. Пропуск уведомления.
```

## Что делать, если нужно отправить сообщение новому пользователю?

### Вариант 1: Попросить пользователя написать боту

1. Создайте публичную ссылку на бота: `https://t.me/your_bot_name`
2. Пользователь переходит по ссылке и нажимает "Start"
3. После этого бот может отправлять сообщения

### Вариант 2: Deep Linking

Используйте deep links для автоматического запуска бота:

```
https://t.me/your_bot_name?start=unique_code
```

Когда пользователь перейдет по ссылке и нажмет "Start", бот получит параметр `unique_code` в команде `/start unique_code`.

### Вариант 3: Inline-кнопки

Если пользователь уже в чате с ботом, используйте inline-кнопки для взаимодействия.

## Проверка возможности отправки сообщения

В коде бота есть проверка:

```python
# В scheduler.py функция get_all_active_users() возвращает только пользователей
# с подключенными календарями, которые уже взаимодействовали с ботом
active_users = db.get_all_active_users()
```

Это гарантирует, что бот пытается отправить сообщения только пользователям, которые:
1. Отправили `/start` (зарегистрированы в базе)
2. Подключили календарь (активные пользователи)

## Исключения из правил

### Группы и каналы

- В группах и каналах бот может отправлять сообщения, если он добавлен как участник
- Но для личных сообщений правило остается: пользователь должен написать боту первым

### Административные функции

- Некоторые административные функции могут работать иначе
- Но для обычных уведомлений правило остается

## Рекомендации

1. **Всегда просите пользователей отправить `/start`** перед использованием бота
2. **Используйте deep links** для автоматизации регистрации
3. **Обрабатывайте ошибки** при отправке сообщений (уже реализовано)
4. **Логируйте ошибки** для диагностики проблем

## Улучшения в коде

В последней версии кода добавлена улучшенная обработка ошибок:

```python
async def send_notification(bot: Bot, user_id: int, event: Dict, calendar_type: str):
    try:
        # ... отправка сообщения ...
    except BadRequest as e:
        if 'chat not found' in str(e).lower():
            logger.warning(f"Пользователь {user_id} не зарегистрирован в боте")
    except Forbidden as e:
        if 'bot was blocked' in str(e).lower():
            logger.warning(f"Пользователь {user_id} заблокировал бота")
        elif 'user is deactivated' in str(e).lower():
            logger.warning(f"Пользователь {user_id} деактивировал аккаунт")
```

Это позволяет:
- Корректно обрабатывать ошибки
- Не прерывать работу бота при ошибках
- Логировать проблемы для диагностики

