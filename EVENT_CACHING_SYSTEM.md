# Система кэширования событий

## Обзор

Бот теперь использует систему кэширования событий из календарей в собственную базу данных. Это позволяет:

- ✅ Уменьшить количество запросов к API календарей
- ✅ Улучшить производительность проверки уведомлений
- ✅ Отслеживать изменения событий
- ✅ Хранить историю событий (прошедшие и будущие)
- ✅ Гибко управлять уведомлениями на основе пользовательских настроек

## Архитектура

### 1. Таблица `cached_events`

События хранятся в таблице `cached_events` со следующей структурой:

- `id` - уникальный ID записи
- `user_id` - ID пользователя Telegram
- `calendar_type` - тип календаря (`google` или `yandex`)
- `event_id` - уникальный ID события в календаре
- `summary` - название события
- `description` - описание события
- `location` - место проведения
- `start_time` - время начала события
- `end_time` - время окончания события
- `html_link` - ссылка на событие в календаре
- `last_synced_at` - время последней синхронизации
- `created_at` - время создания записи
- `updated_at` - время последнего обновления

**Индексы:**
- `(user_id, calendar_type)` - для быстрого поиска событий пользователя
- `(start_time)` - для сортировки по времени
- `(user_id, start_time)` - для поиска событий в диапазоне времени

### 2. Процесс синхронизации

Функция `sync_events_from_calendars()`:

1. Получает всех активных пользователей с подключенными календарями
2. Для каждого календаря:
   - Запрашивает события из API календаря (от 30 дней назад до 90 дней вперед)
   - Сохраняет/обновляет события в БД
   - Удаляет старые события (более 7 дней назад)
3. Отслеживает изменения: если событие изменилось, обновляет его в БД

### 3. Проверка уведомлений

Функция `check_and_notify_events()`:

1. Получает события из кэшированной БД (не из API календарей)
2. Фильтрует события по временному диапазону (на основе настроек пользователя)
3. Проверяет, не отправляли ли уже уведомление
4. Отправляет уведомления пользователям

## Использование

### Синхронизация событий

Синхронизация должна выполняться периодически (рекомендуется каждые 15-30 минут):

**Через cron-сервис:**
```
URL: https://yourusername.pythonanywhere.com/cron/sync-events
Интервал: каждые 15-30 минут
```

**Через PythonAnywhere Scheduled Tasks:**
- Создайте задачу, которая вызывает `/cron/sync-events`
- Установите интервал: каждые 15-30 минут

### Проверка уведомлений

Проверка уведомлений выполняется чаще (рекомендуется каждые 1-5 минут):

**Через cron-сервис:**
```
URL: https://yourusername.pythonanywhere.com/cron/check-events
Интервал: каждые 1-5 минут
```

**Через PythonAnywhere Scheduled Tasks:**
- Создайте задачу, которая вызывает `/cron/check-events`
- Установите интервал: каждые 1-5 минут

### Комбинированный endpoint

Для удобства можно использовать `/cron/run-all`, который выполняет:
1. Синхронизацию событий
2. Проверку уведомлений
3. Проверку рассылок

## API Endpoints

### `/cron/sync-events`

Синхронизирует события из календарей в БД.

**Ответ:**
```json
{
  "status": "success",
  "message": "Синхронизация событий выполнена"
}
```

### `/cron/check-events`

Проверяет события из БД и отправляет уведомления.

**Ответ:**
```json
{
  "status": "success",
  "message": "Проверка событий выполнена"
}
```

### `/cron/run-all`

Выполняет все задачи (синхронизация + проверка уведомлений + проверка рассылок).

**Ответ:**
```json
{
  "status": "success",
  "message": "Все задачи выполнены",
  "tasks": ["sync-events", "check-events", "check-broadcasts"]
}
```

## Методы работы с кэшем

### Сохранение/обновление события

```python
db.save_or_update_event(
    user_id=user_id,
    calendar_type='google',
    event_id='event_123',
    summary='Встреча',
    description='Описание',
    location='Офис',
    start_time=datetime(2024, 1, 15, 10, 0),
    end_time=datetime(2024, 1, 15, 11, 0),
    html_link='https://calendar.google.com/...'
)
```

### Получение событий для уведомлений

```python
events = db.get_events_for_notification(
    user_id=user_id,
    time_min=datetime.utcnow(),
    time_max=datetime.utcnow() + timedelta(minutes=15)
)
```

### Получение всех событий пользователя

```python
events = db.get_cached_events(
    user_id=user_id,
    calendar_type='google',  # опционально
    time_min=datetime(2024, 1, 1),  # опционально
    time_max=datetime(2024, 12, 31)  # опционально
)
```

### Удаление старых событий

```python
deleted_count = db.delete_old_events(
    user_id=user_id,
    calendar_type='google',
    before_date=datetime.utcnow() - timedelta(days=7)
)
```

### Очистка всех событий календаря

```python
deleted_count = db.clear_user_events(
    user_id=user_id,
    calendar_type='google'
)
```

## Преимущества новой системы

### 1. Производительность

- **Раньше**: Каждый раз при проверке уведомлений делались запросы к API календарей
- **Теперь**: События читаются из локальной БД (быстрее в 10-100 раз)

### 2. Надежность

- **Раньше**: Если API календаря недоступен, уведомления не работают
- **Теперь**: Уведомления работают даже при временной недоступности API (используются кэшированные данные)

### 3. Гибкость

- Можно хранить события на любой период (прошедшие и будущие)
- Легко отслеживать изменения событий
- Можно анализировать историю событий

### 4. Экономия ресурсов

- Меньше запросов к API календарей (соблюдение rate limits)
- Меньше нагрузки на сервер календарей
- Быстрее работа бота

## Настройка интервалов

### Рекомендуемые интервалы

**Синхронизация событий (`/cron/sync-events`):**
- Минимум: каждые 15 минут
- Оптимально: каждые 30 минут
- Максимум: каждый час

**Проверка уведомлений (`/cron/check-events`):**
- Минимум: каждую минуту
- Оптимально: каждые 2-5 минут
- Максимум: каждые 10 минут

### Почему разные интервалы?

- **Синхронизация** - тяжелая операция (много запросов к API), выполняется реже
- **Проверка уведомлений** - легкая операция (чтение из БД), выполняется чаще для точности

## Миграция данных

При первом запуске новой версии:

1. Таблица `cached_events` создается автоматически
2. При первой синхронизации события загружаются из календарей
3. Старые события (более 7 дней) автоматически удаляются

**Важно:** После обновления кода обязательно запустите синхронизацию вручную:

```bash
curl https://yourusername.pythonanywhere.com/cron/sync-events
```

## Отладка

### Проверка количества событий в кэше

```python
from database import Database
db = Database()
events = db.get_cached_events(user_id=123456789)
print(f"Событий в кэше: {len(events)}")
```

### Проверка синхронизации

Проверьте логи после вызова `/cron/sync-events`:
```
=== Начало синхронизации событий ===
Найдено активных пользователей: 1
Синхронизация событий для пользователя 123456789
Получено 15 событий из google для пользователя 123456789
Синхронизировано 15 событий для календаря google пользователя 123456789
=== Синхронизация завершена: добавлено/обновлено 15, удалено 0 ===
```

### Проверка уведомлений

Проверьте логи после вызова `/cron/check-events`:
```
=== Начало проверки событий ===
Найдено активных пользователей: 1
Обработка пользователя 123456789
Интервал уведомлений для пользователя 123456789: 15 минут
Найдено 2 событий в БД для пользователя 123456789 в диапазоне уведомлений
Отправка уведомления о событии 'Встреча' пользователю 123456789
Уведомление отправлено пользователю 123456789 о событии event_123
```

## Ограничения

1. **Размер БД**: События хранятся в SQLite, при большом количестве пользователей может потребоваться оптимизация
2. **Период хранения**: События старше 7 дней автоматически удаляются (можно настроить)
3. **Синхронизация**: При изменении события в календаре оно обновится только при следующей синхронизации

## Будущие улучшения

- [ ] Добавить инкрементальную синхронизацию (только измененные события)
- [ ] Добавить веб-интерфейс для просмотра кэшированных событий
- [ ] Добавить статистику по синхронизации
- [ ] Добавить уведомления об ошибках синхронизации
- [ ] Добавить возможность ручной синхронизации через бота

